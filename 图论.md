# 树

### 最近公共祖先（LCA）

```c++
#include <bits/stdc++.h>

#define MXN 500005
using namespace std;
std::vector<int> v[MXN];

int fa[MXN][31], dep[MXN];
int n, m, s;
int a, b;

// dfs，用来为 lca 算法做准备。接受两个参数：dfs 起始节点和它的父亲节点。
void dfs(int root, int fno) {
    // 初始化：第 2^0 = 1 个祖先就是它的父亲节点，dep 也比父亲节点多 1。
    fa[root][0] = fno;
    dep[root] = dep[fa[root][0]] + 1;
    // 初始化：其他的祖先节点：第 2^i 的祖先节点是第 2^(i-1) 的祖先节点的第
    // 2^(i-1) 的祖先节点。
    for (int i = 1; i < 31; ++i) {
        fa[root][i] = fa[fa[root][i - 1]][i - 1];
    }
    // 遍历子节点来进行 dfs。
    int sz = v[root].size();
    for (int i = 0; i < sz; ++i) {
        if (v[root][i] == fno) continue;
        dfs(v[root][i], root);
    }
}

// lca。用倍增算法算取 x 和 y 的 lca 节点。
int lca(int x, int y) {
    // 令 y 比 x 深。
    if (dep[x] > dep[y]) swap(x, y);
    // 令 y 和 x 在一个深度。
    int tmp = dep[y] - dep[x];
    for (int j = 0; tmp; ++j, tmp >>= 1)
        if (tmp & 1)  y = fa[y][j];
    // 如果这个时候 y = x，那么 x，y 就都是它们自己的祖先。
    if (y == x) return x;
    // 不然的话，找到第一个不是它们祖先的两个点。
    for (int j = 30; j >= 0 && y != x; --j) {
        if (fa[x][j] != fa[y][j]) {
            x = fa[x][j];
            y = fa[y][j];
        }
    }
    // 返回结果。
    return fa[x][0];
}

int main() {
    // 读入树：节点数一共有 n 个。
    cin >> n >> m >> s;
    for (int i = 1; i < n; ++i) {
        cin >> a >> b;
        v[a].push_back(b);
        v[b].push_back(a);
    }
    // 为了计算 lca 而使用 dfs。
    dfs(s, 0);
    for (int i = 0; i < m; ++i) {
        cin >> a >> b;
        cout << lca(a, b) << endl;
    }
    return 0;
}
```

### 树的重心

定义：对于树上的每一个点，计算其所有子树中最大的子树节点数，这个值最小的点就是这棵树的重心。

```c++
//算法核心为：num[curr][fai] = n - sum - 1;
//套这个模板之前先想想能不能用其他所有子树的目标值算出父子树的目标值

#include <iostream>
#include <vector>
#define mxn 20005
using namespace std;
int caseNum, n, a, b;
vector<int> v[mxn];		//v[i][j]表示第i个结点的第j个邻结点
vector<int> num[mxn];	//num[i][j]表示第i个结点的第j棵子树结点数
int minNum, minCurr;	//minNum存放最小子树结点数，minCurr存放重心位置

int getCentroid(int curr, int fa) {
    int fai, sum = 0, maxCurrNum = 0;	
    //当前结点的第fai个邻结点为父节点
    //sum为当前结点除父节点子树以外所有子树节点之和
    //maxCurrNum为当前结点所有子树结点数中最大的
    for (int i = 0; i < v[curr].size(); i++) {
        if (v[curr][i] == fa) {
            fai = i;
            continue;
        }
        num[curr][i] = getCentroid(v[curr][i], curr);
        sum += num[curr][i];
        maxCurrNum = max(maxCurrNum, num[curr][i]);
    }
    if (curr!=1) num[curr][fai] = n - sum - 1;
    maxCurrNum = max(maxCurrNum, num[curr][fai]);
    if (minNum > maxCurrNum) {
        minNum = maxCurrNum;
        minCurr = curr;
    }
    return sum + 1;
}

void init()
{
    for (int i=1;i<=n;i++){
        v[i].clear();
        num[i].clear();
    }
}
int main() {
    cin >> caseNum;		//caseNum次测试
    for (int i = 1; i <= caseNum; i++) {
        init();
        cin >> n;
        minNum = n + 1;
        for (int j = 1; j < n; j++) {
            cin >> a >> b;
            v[a].push_back(b);
            num[a].push_back(0);
            v[b].push_back(a);
            num[b].push_back(0);
        }
        getCentroid(1, 0);
        cout << minCurr << " " << minNum << endl;
    }
    return 0;
}
```

### 树的中心

```c++
#include <bits/stdc++.h>
#define mxn 100005
using namespace std;
int n, a, b;
vector<int> v[mxn];        //v[i][j]表示第i个结点的第j个邻结点
vector<int> num[mxn];    //num[i][j]表示第i个结点的第j棵子树方向的离心率（最远距离）
int minDis, center;    //minDis存放中心的离心率，center存放中心

int dfs(int curr, int fa) {
    //先dfs把除父节点方向的所有离心率填完
    int maxDist = 0;    //maxDist为当前结点除父节点外所有方向中最大的离心率
    for (int i = 0; i < v[curr].size(); i++) {
        if (v[curr][i] == fa) continue;
        num[curr][i] = dfs(v[curr][i], curr) + 1;
        maxDist = max(maxDist, num[curr][i]);
    }
    return maxDist;
}

void repair(int curr, int fa, int faMaxDist) {
    //再把每个结点的父节点方向的离心率填上
    //faMaxDist为父节点除了往curr方向外其他方向最大的离心率
    int first = 0, second = 0;
    //先把父节点方向的离心率填上，选出所有方向离心率中最大的两个
    for (int i = 0; i < v[curr].size(); i++) {
        if (v[curr][i] == fa) {
            num[curr][i] = faMaxDist + 1;
            if (num[curr][i] > first) {
                second = first;
                first = num[curr][i];
            } else if (num[curr][i] > second) second = num[curr][i];
        }
        if (num[curr][i] > first) {
            second = first;
            first = num[curr][i];
        } else if (num[curr][i] > second) second = num[curr][i];
    }
    //更新minDis
    if (first < minDis) {
        minDis = first;
        center = curr;
    }
    //向下dfs
    for (int i = 0; i < v[curr].size(); i++) {
        if (v[curr][i] == fa) continue;
        if (num[curr][i] == first) repair(v[curr][i], curr, second);
        else repair(v[curr][i], curr, first);
    }
}

int main() {
    cin >> n;
    minDis = n + 1;
    for (int j = 1; j < n; j++) {
        cin >> a >> b;
        v[a].push_back(b);
        num[a].push_back(0);
        v[b].push_back(a);
        num[b].push_back(0);
    }
    dfs(1, 0);
    repair(1, 0, 0);
    cout << center << " " << minDis;
    return 0;
}
```

